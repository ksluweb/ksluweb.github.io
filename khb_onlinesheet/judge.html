<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>関西俳句バトル2026　評価入力システム</title>
  <link rel="stylesheet" href="judge.css">
</head>

<body>
  <div class="wrap">
    <header>
      <h1>関西俳句バトル2026　評価入力システム</h1>
      <p class="judge">審査員名：読み込み中…</p>
      <h2><span id="match-label">対戦情報を取得中…</span></h2>
      <div id="match-status" class="status-message"></div>

    </header>

    <section class="card">
      <!-- 表形式の3カラムグリッド -->
      <div class="score-grid" id="teams">
        <!-- 1行目：サイド見出し／対戦情報／サイド見出し -->
        <div class="cell side side-red" aria-hidden="true">紅</div>
        <div class="cell mid head"><span id="grid-match-title">試合名</span></div>
        <div class="cell side side-white" aria-hidden="true">白</div>

        <!-- 2行目：チーム名 -->
        <div class="cell team-name">
          <div class="name" id="team-red-name">紅チーム</div>
        </div>
        <div class="cell mid label text-ink">対戦名</div>
        <div class="cell team-name">
          <div class="name" id="team-white-name">白チーム</div>
        </div>

        <!-- 3行目：作品点 -->
        <div class="cell team-field">
          <select aria-label="紅 作品点" class="ipt works" data-side="red">
            <option value="" disabled selected>選択</option>
            <option value="10">10</option>
            <option value="9">9</option>
            <option value="8">8</option>
            <option value="7">7</option>
            <option value="6">6</option>
            <option value="5">5</option>
            <option value="4">4</option>
            <option value="3">3</option>
            <option value="2">2</option>
            <option value="1">1</option>
          </select>
        </div>
        <div class="cell mid label">作品点</div>
        <div class="cell team-field">
          <select aria-label="白 作品点" class="ipt works" data-side="white">
            <option value="" disabled selected>選択</option>
            <option value="10">10</option>
            <option value="9">9</option>
            <option value="8">8</option>
            <option value="7">7</option>
            <option value="6">6</option>
            <option value="5">5</option>
            <option value="4">4</option>
            <option value="3">3</option>
            <option value="2">2</option>
            <option value="1">1</option>
          </select>
        </div>

        <!-- 4行目：鑑賞点 -->
        <div class="cell team-field">
          <select aria-label="紅 鑑賞点" class="ipt app" data-side="red">
            <option value="" disabled selected>選択</option>
            <option value="2">2</option>
            <option value="1">1</option>
            <option value="0">0</option>
          </select>
        </div>
        <div class="cell mid label">鑑賞点</div>
        <div class="cell team-field">
          <select aria-label="白 鑑賞点" class="ipt app" data-side="white">
            <option value="" disabled selected>選択</option>
            <option value="2">2</option>
            <option value="1">1</option>
            <option value="0">0</option>
          </select>
        </div>

        <!-- 5行目：合計点 -->
        <div class="cell team-field">
          <div class="bigval total" aria-live="polite" data-side="red">0</div>
        </div>
        <div class="cell mid label">合計点</div>
        <div class="cell team-field">
          <div class="bigval total" aria-live="polite" data-side="white">0</div>
        </div>

        <!-- 6行目：旗 -->
        <div class="cell team-field">
          <div class="flag red" aria-live="polite" data-flag="red" data-side="red"></div>
        </div>
        <div class="cell mid label">旗</div>
        <div class="cell team-field">
          <div class="flag white" aria-live="polite" data-flag="white" data-side="white"></div>
        </div>
      </div>



      <div class="submit-area">
        <button class="primary" id="submitBtn">送信</button>
        <div class="result" id="result" aria-live="polite"></div>
        <div class="notes">※ この画面から送信された結果はシステムに保存されます。</div>
      </div>
    </section>

    <div id="match-header" class="technical-info">
      <!-- 技術情報 -->
    </div>
  </div>

  <script src="config.js"></script>
  <script>
    (function () {
      const $ = (sel, root = document) => root.querySelector(sel);
      const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

      const CONFIG = window.JUDGE_APP_CONFIG || {};
      const FUNCTION_URL = CONFIG.FUNCTION_URL;
      const SUPABASE_ANON_KEY = CONFIG.SUPABASE_ANON_KEY;
      const CONFIG_ERROR = '設定ファイル(config.js)の読み込みに失敗しました。';
      const FLAG_SYMBOL = '◆';

      function parseOrZero(s) {
        if (!s) return 0;
        const n = Number(s);
        return Number.isFinite(n) ? n : 0;
      }

      function getSideElems(side) {
        return {
          works: $(`.works[data-side="${side}"]`),
          app: $(`.app[data-side="${side}"]`),
          total: $(`.total[data-side="${side}"]`),
          flag: $(`.flag[data-side="${side}"]`),
        };
      }

      // 合計点を更新
      function updateTotals() {
        ['red', 'white'].forEach(side => {
          const elems = getSideElems(side);
          const w = parseOrZero(elems.works && elems.works.value);
          const a = parseOrZero(elems.app && elems.app.value);
          const total = w + a;
          if (elems.total) elems.total.textContent = String(total);
        });
        updateFlagsAuto();
      }

      // 鑑賞点の排他（どちらか片方だけ）
      function enforceAppExclusion(changedSide) {
        const r = getSideElems('red');
        const w = getSideElems('white');

        const hasPoint = (el) => el && (el.value === '1' || el.value === '2');
        const lockOther = (other) => {
          if (!other) return;
          other.value = '0';
          other.disabled = true;
        };
        const unlock = (el) => {
          if (!el) return;
          el.disabled = false;
        };

        const redHas = hasPoint(r.app);
        const whiteHas = hasPoint(w.app);

        const prefer = changedSide || (redHas ? 'red' : (whiteHas ? 'white' : null));

        if (prefer === 'red') {
          if (redHas) {
            lockOther(w.app);
            unlock(r.app);
          } else {
            unlock(w.app);
          }
        } else if (prefer === 'white') {
          if (whiteHas) {
            lockOther(r.app);
            unlock(w.app);
          } else {
            unlock(r.app);
          }
        } else {
          unlock(r.app);
          unlock(w.app);
        }
      }

      // 旗は自動で決定する（合計点が高い方、同点なら作品点が高い方）
      function updateFlagsAuto() {
        const r = getSideElems('red');
        const w = getSideElems('white');

        const rTotal = parseOrZero(r.total && r.total.textContent);
        const wTotal = parseOrZero(w.total && w.total.textContent);

        if (r.flag) r.flag.textContent = '';
        if (w.flag) w.flag.textContent = '';

        if (rTotal > wTotal) {
          if (r.flag) r.flag.textContent = FLAG_SYMBOL;
        } else if (wTotal > rTotal) {
          if (w.flag) w.flag.textContent = FLAG_SYMBOL;
        } else {
          // 合計同点 → 作品点で判定
          const rWork = parseOrZero(r.works && r.works.value);
          const wWork = parseOrZero(w.works && w.works.value);
          if (rWork > wWork) {
            if (r.flag) r.flag.textContent = FLAG_SYMBOL;
          } else if (wWork > rWork) {
            if (w.flag) w.flag.textContent = FLAG_SYMBOL;
          } else {
            // それでも同点なら旗なし
          }
        }
      }

      const submitBtn = $('#submitBtn');
      const result = $('#result');

      let initialSent = false; // 初回送信済みかどうか
      let inEdit = true;  // 現在編集中かどうか
      let editCount = 0;     // 修正送信回数
      let isSubmitting = false;
      let prevBtnLabel = '';

      let currentMatchId = null; // ★ 追加：現在の試合 ID
      let currentEpoch = null;
      let hasLoadedSubmission = false;

      function setInputsEditable(editable) {
        $$('.ipt').forEach(i => { i.disabled = !editable; });
        document.body.classList.toggle('inputs-locked', !editable);
      }

      function setResult(msg, ok) {
        if (!result) return;
        result.textContent = msg;
        result.classList.toggle('ok', !!ok);
        result.classList.toggle('ng', ok === false);
      }

      function beginLoading(label) {
        if (!submitBtn) return;
        prevBtnLabel = submitBtn.textContent;
        submitBtn.textContent = label || '送信中…';
        submitBtn.disabled = true;
        submitBtn.setAttribute('aria-busy', 'true');
      }

      function endLoading() {
        if (!submitBtn) return;
        submitBtn.disabled = false;
        submitBtn.removeAttribute('aria-busy');
        submitBtn.textContent = prevBtnLabel || '送信';
      }

      // 試合 or epoch 切り替え時に UI を初期状態に戻す
      function resetForNewContext() {
        $$('.ipt').forEach(el => {
          el.disabled = false;
          if (el.tagName === 'SELECT' || el.tagName === 'INPUT') {
            el.value = '';
          }
        });

        $$('.total').forEach(el => { el.textContent = '0'; });
        $$('.flag').forEach(el => { el.textContent = ''; });
        document.body.classList.remove('inputs-locked');

        initialSent = false;
        inEdit = true;
        editCount = 0;
        hasLoadedSubmission = false; // ★ 新しい試合/epoch では再読み込みを許可
        if (submitBtn) submitBtn.textContent = '送信';

        if (result) {
          result.textContent = '';
          result.classList.remove('ok', 'ng');
        }

        enforceAppExclusion();
        updateTotals();
        updateFlagsAuto();
      }

      // サーバから取得した提出済みデータを画面に反映する
      function applySubmissionFromServer(submission) {
        if (!submission || !submission.red || !submission.white) return;

        const red = getSideElems('red');
        const white = getSideElems('white');

        const toInputValue = (n) =>
          (typeof n === 'number' && Number.isFinite(n)) ? String(n) : '';

        if (red.works) red.works.value = toInputValue(submission.red.work);
        if (red.app) red.app.value = toInputValue(submission.red.app);
        if (white.works) white.works.value = toInputValue(submission.white.work);
        if (white.app) white.app.value = toInputValue(submission.white.app);

        enforceAppExclusion();
        updateTotals();
        updateFlagsAuto();

        initialSent = true;
        inEdit = false;
        editCount = Math.max(0, (submission.revision || 1) - 1);

        setInputsEditable(false);
        if (submitBtn) submitBtn.textContent = '修正する';

        const revMessage =
          editCount > 0
            ? `（サーバ上では修正送信が ${editCount} 回行われています）`
            : '';

        setResult(`前回送信済みの内容を読み込みました${revMessage}`, true);
      }

      function getToken() {
        const params = new URLSearchParams(location.search);
        return params.get('token') || '';
      }

      // 対戦情報を取得
      async function loadMatchInfo() {
        const token = getToken();
        const labelEl = document.getElementById('match-label');
        if (labelEl) labelEl.classList.remove('text-error');

        const judgeEl = document.querySelector('.judge');
        const midLabelEl = document.getElementById('grid-match-title');
        const boutLabelEl = document.getElementById('match-header');
        if (!labelEl) return;

        if (!FUNCTION_URL || !SUPABASE_ANON_KEY) {
          labelEl.textContent = CONFIG_ERROR;
          labelEl.classList.add('text-error');
          return;
        }

        if (!token) {
          labelEl.textContent = 'URL に token パラメータがありません。';
          labelEl.classList.add('text-error');
          return;
        }

        try {
          const res = await fetch(FUNCTION_URL, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': 'Bearer ' + SUPABASE_ANON_KEY,
            },
            body: JSON.stringify({ token, mode: 'info' }),
          });

          const text = await res.text();
          let data = {};
          try { data = JSON.parse(text); } catch (_) { }

          if (!res.ok || !data.ok) {
            const msg = data.error || data.message || res.status;
            labelEl.textContent = '対戦情報取得失敗: ' + msg;
            labelEl.classList.add('text-error');
            return;
          }

          const match = data.match || {};
          const epoch = data.epoch;
          const accepting = data.accepting;
          const bout = data.bout || null;
          const judgeName = data.judge_name || null;
          const submission = data.submission || null;

          const newMatchId = match.id || null;

          // ★ 試合が変わった場合 → 完全リセット
          if (newMatchId && currentMatchId !== null && currentMatchId !== newMatchId) {
            currentMatchId = newMatchId;
            currentEpoch = (typeof epoch === 'number') ? epoch : null;
            resetForNewContext();
          } else if (currentMatchId === null && newMatchId) {
            // 初回
            currentMatchId = newMatchId;
            currentEpoch = (typeof epoch === 'number') ? epoch : null;
          }

          // ★ 同じ試合内で epoch が変わった場合 → リセット
          if (typeof epoch === 'number') {
            if (currentEpoch !== null && currentEpoch !== epoch) {
              currentEpoch = epoch;
              resetForNewContext();
            } else if (currentEpoch === null) {
              currentEpoch = epoch;
            }
          }

          const parts = [];

          if (match.name) {
            parts.push(match.name);
          }

          if (bout && bout.label) {
            parts.push(bout.label);
          } else if (typeof epoch === 'number') {
            parts.push(`第${epoch}対戦`);
          }

          // 審査員名はここには表示しない (parts.pushしない)
          if (judgeName && judgeEl) {
            judgeEl.textContent = `審査員名：${judgeName} 先生`;
          }

          // 受付停止情報はメイン見出しではなく専用エリアへ
          const statusEl = document.getElementById('match-status');
          if (statusEl) {
            statusEl.textContent = (accepting === false) ? '現在は受付停止中です' : '';
          }

          labelEl.textContent = parts.join(' ／ ');

          // ★ 1行目中央：試合名（例: Aブロック 第1試合）
          // ... (keep midLabelEl logic or update if needed? User didn't specify table header changes other than black color for bout name)
          // Actually user said "表中の対戦（「次鋒戦」と表示されているところ）を他と同様に黒く" - Done via CSS/HTML.

          const matchTitle =
            (match.name && match.name.trim() !== '')
              ? match.name
              : (match.code || '試合');

          if (midLabelEl) {
            midLabelEl.textContent = matchTitle;
          }

          // ★ 2行目中央：対戦名（先鋒戦など）
          const boutTitleCell = document.querySelector('#teams .cell.mid.label');
          if (boutTitleCell) {
            if (bout && bout.label) {
              boutTitleCell.textContent = bout.label;
              boutTitleCell.classList.add('text-ink'); // Ensure class is present
            } else if (typeof epoch === 'number') {
              boutTitleCell.textContent = `第${epoch}対戦`;
            } else {
              boutTitleCell.textContent = '対戦名';
            }
          }

          // ★ 左右：チーム名
          const redTeamEl = document.getElementById('team-red-name');
          const whiteTeamEl = document.getElementById('team-white-name');

          if (redTeamEl) {
            redTeamEl.textContent =
              (match.red_team_name && match.red_team_name.trim() !== '')
                ? match.red_team_name
                : '紅チーム';
          }

          if (whiteTeamEl) {
            whiteTeamEl.textContent =
              (match.white_team_name && match.white_team_name.trim() !== '')
                ? match.white_team_name
                : '白チーム';
          }

          // 技術情報（表の下）
          if (boutLabelEl) {
            const segs = [];
            if (match.code) {
              segs.push(`試合コード: ${match.code}`);
            }
            if (typeof epoch === 'number') {
              segs.push(`第${epoch}対戦`);
            }
            // ポジションはここには表示しない

            if (segs.length > 0) {
              boutLabelEl.textContent = '［技術情報］' + segs.join(' ／ ');
            } else {
              boutLabelEl.textContent = '';
            }
          }

          // 提出済みデータがあれば、新しい試合/epoch で一度だけ適用
          if (submission && !hasLoadedSubmission) {
            applySubmissionFromServer(submission);
            hasLoadedSubmission = true;
          }

        } catch (err) {
          console.error('loadMatchInfo error', err);
          labelEl.textContent = '対戦情報の取得中にエラーが発生しました。';
          labelEl.classList.add('text-error');
        }
      }

      // Supabase Edge Function へ送信
      async function sendToServer(isEdit) {
        const token = getToken();
        if (!FUNCTION_URL || !SUPABASE_ANON_KEY) {
          setResult(CONFIG_ERROR, false);
          return false;
        }
        if (!token) {
          setResult('URL に token パラメータがありません', false);
          return false;
        }

        const red = getSideElems('red');
        const white = getSideElems('white');

        const payload = {
          red: {
            work: parseOrZero(red.works && red.works.value),
            app: parseOrZero(red.app && red.app.value),
            total: parseOrZero(red.total && red.total.textContent),
            flag: !!(red.flag && red.flag.textContent === FLAG_SYMBOL),
          },
          white: {
            work: parseOrZero(white.works && white.works.value),
            app: parseOrZero(white.app && white.app.value),
            total: parseOrZero(white.total && white.total.textContent),
            flag: !!(white.flag && white.flag.textContent === FLAG_SYMBOL),
          },
          isEdit: !!isEdit,
        };

        if (payload.red.work < 0 || payload.white.work < 0) {
          setResult('作品点は 0 以上で入力してください。', false);
          return false;
        }
        if (payload.red.app < 0 || payload.white.app < 0) {
          setResult('鑑賞点は 0 以上で入力してください。', false);
          return false;
        }
        if (payload.red.app === 0 && payload.white.app === 0) {
          setResult('鑑賞点はいずれかのチームに1点または2点を入れてください。', false);
          return false;
        }

        try {
          const res = await fetch(FUNCTION_URL, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': 'Bearer ' + SUPABASE_ANON_KEY,
            },
            body: JSON.stringify({ token, payload }),
          });

          const text = await res.text();
          console.log('edge function status =', res.status, 'body =', text);

          let data = {};
          try { data = JSON.parse(text); } catch (_) { }

          if (!res.ok || !data.ok) {
            const msg = data.error || data.message || res.status;
            setResult(`送信失敗: ${msg}`, false);
            return false;
          }

          return true;
        } catch (err) {
          console.error('sendToServer error', err);
          setResult('送信中にエラーが発生しました。', false);
          return false;
        }
      }

      // ボタンクリックで送信／修正モード切り替え
      if (submitBtn) {
        submitBtn.addEventListener('click', async () => {
          if (isSubmitting) return;

          // まだ一度も送信していない → 初回送信
          if (!initialSent) {
            isSubmitting = true;
            beginLoading('送信中…');
            const ok = await sendToServer(false);
            endLoading();
            isSubmitting = false;
            if (!ok) return;

            initialSent = true;
            inEdit = false;
            editCount = 0;
            setInputsEditable(false);
            submitBtn.textContent = '修正する';
            setResult('送信成功', true);
            return;
          }

          // 送信済みで、今は閲覧モード → 修正モードへ入る
          if (!inEdit) {
            inEdit = true;
            setInputsEditable(true);
            submitBtn.textContent = '修正を送信する';
            setResult('点数を修正して「修正を送信する」を押してください。', null);
            return;
          }

          // 修正モード中 → 修正送信
          isSubmitting = true;
          beginLoading('修正送信中…');
          const ok = await sendToServer(true);
          endLoading();
          isSubmitting = false;
          if (!ok) return;

          inEdit = false;
          editCount++;
          setInputsEditable(false);
          submitBtn.textContent = '修正する';
          setResult(`修正送信しました（修正回数: ${editCount}回）`, true);
        });
      }

      // 入力イベントを監視
      function onValueChange(e) {
        const t = e.target;
        if (!t.classList.contains('ipt')) return;

        const side = t.getAttribute('data-side');
        if (t.classList.contains('app')) {
          enforceAppExclusion(side);
        }

        updateTotals();
        // 合計更新時に自動で旗も更新
        // updateFlagsAuto() は updateTotals 内で呼んでいる
        if (initialSent && !inEdit) {
          inEdit = true;
          setInputsEditable(true);
          if (submitBtn) submitBtn.textContent = '修正を送信する';
          setResult('点数を修正して「修正を送信する」を押してください。', null);
        }
      }

      $$('.ipt').forEach(el => {
        el.addEventListener('input', onValueChange);
        if (el.tagName === 'SELECT') {
          el.addEventListener('change', onValueChange);
        }
      });

      // 初期状態
      enforceAppExclusion();
      updateTotals();
      updateFlagsAuto();

      // 画面表示時に対戦情報を読み込む
      loadMatchInfo();

      // 数秒おきに対戦情報を自動更新（試合/epoch変更の検知にも使う）
      setInterval(() => {
        if (document.visibilityState === 'visible') {
          loadMatchInfo();
        }
      }, 5000);

    })();
  </script>



</body>

</html>
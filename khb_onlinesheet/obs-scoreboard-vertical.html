<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KHB Scoreboard (OBS Vertical)</title>
    <!-- admin-vertical.css を読み込んでデザインを統一 -->
    <link rel="stylesheet" href="admin-vertical.css" />
    <style>
        /* OBS用微調整: 背景透過 */
        html,
        body {
            background-color: transparent !important;
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* 不要なスクロールバーを消す */
        }

        /* Wrap: 余白調整 */
        .scoreboard-wrapper {
            max-width: none;
            margin: 0;
            padding: 0;
            background: rgba(255, 255, 255, 0.95);
            width: fit-content;
        }

        /* 文字サイズのスケーリング（必要であれば） */
        table {
            /* 縦1080基準で大きめに -> 少し縮小 */
            zoom: 1.0;
        }

        .status-bar {
            position: fixed;
            top: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 4px;
            font-size: 12px;
        }

        [v-cloak] {
            display: none;
        }
    </style>
</head>

<body>

    <div id="app">
        <!-- admin.css の .card クラスなどで囲むと影などがつく -->
        <div class="card" style="width: 100%; box-sizing: border-box; opacity: 0; transition: opacity 0.5s ease;"
            id="mainCard">
            <div id="scoreboardContainer" class="scoreboard-wrapper">
                <!-- ここにJSでテーブルを描画 -->
                <div style="text-align:center; padding:100px; color:#666; display:none;">
                    <!-- Connecting... text removed -->
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar" id="statusBar" style="display:none;">Connecting...</div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- 共通ロジック読み込み -->
    <script src="scoreboard.js"></script>
    <script>
        (function () {
            const SUPABASE_URL = 'https://ktxwkdpurwamilzzsrfq.supabase.co';
            const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt0eHdrZHB1cndhbWlsenpzcmZxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIzNjAwMTcsImV4cCI6MjA3NzkzNjAxN30.YvZgEi4x0YPuxYswMQjDQdBMVOPY6wkCVfY2hJ0_dL8';

            const headers = {
                'apikey': SUPABASE_ANON_KEY,
                'Authorization': 'Bearer ' + SUPABASE_ANON_KEY,
                'Content-Type': 'application/json',
            };

            // 状態管理
            let currentMatchId = null;
            let currentEpoch = 1;

            const mainCard = document.getElementById('mainCard');
            const scoreboardContainer = document.getElementById('scoreboardContainer');
            const statusBar = document.getElementById('statusBar');

            function setStatus(msg) {
                if (statusBar) statusBar.textContent = msg;
            }

            // khb_score 風スコアボード構築 (縦型レイアウト)
            function buildScoreboard(expectedIds, judgesMap, subMap, meta) {
                if (!scoreboardContainer) return;
                scoreboardContainer.innerHTML = '';

                if (!expectedIds || !expectedIds.length) {
                    return;
                }

                meta = meta || {};
                const matchLabel = meta.matchLabel || '試合名';
                const boutLabelFull = meta.boutLabelFull || '対戦名';
                const redTeam = meta.redTeamName || '紅チーム';
                const whiteTeam = meta.whiteTeamName || '白チーム';

                const table = document.createElement('table');
                table.className = 'scoreboard-v';
                const tbody = document.createElement('tbody');
                table.appendChild(tbody);

                // createCell helper
                const createCell = (text, className, rowSpan, colSpan) => {
                    const td = document.createElement('td');
                    if (className) td.className = className;
                    if (text !== undefined && text !== null) td.textContent = text;
                    if (rowSpan) td.rowSpan = rowSpan;
                    if (colSpan) td.colSpan = colSpan;
                    return td;
                };

                // --- Header Rows ---

                // 1. Top Header: [Red Team Header] [Match Info] [White Team Header]
                const trTop = document.createElement('tr');
                trTop.appendChild(createCell('紅', 'header-team-red', 1, 3)); // 3 cols

                // Handle line breaks: Match name contains full-width space -> <br>
                const displayMatchLabel = (matchLabel || '').replace(/　/g, '<br>');
                const tdMatch = createCell('', 'header-match-info', 1, 1);
                tdMatch.innerHTML = displayMatchLabel;

                trTop.appendChild(tdMatch);
                trTop.appendChild(createCell('白', 'header-team-white', 1, 3)); // 3 cols
                tbody.appendChild(trTop);

                // 2. Team Names Rows
                const trTeam = document.createElement('tr');
                trTeam.appendChild(createCell(redTeam, 'team-name-red', 1, 3)); // 3 cols
                const tdBout = createCell(boutLabelFull, 'header-match-info', 1, 1);
                trTeam.appendChild(tdBout);
                trTeam.appendChild(createCell(whiteTeam, 'team-name-white', 1, 3)); // 3 cols
                tbody.appendChild(trTeam);

                // 3. Column Headers
                // Flag | Total | Work/App || Judge || Work/App | Total | Flag
                const trColHead = document.createElement('tr');

                // Red Side Cols
                trColHead.appendChild(createCell('旗', 'col-header', 1, 1));
                trColHead.appendChild(createCell('合計', 'col-header', 1, 1));
                const tdRedWorkApp = createCell('作品点<br>鑑賞点', 'col-header', 1, 1);
                tdRedWorkApp.innerHTML = '作品点<div class="sub-label">鑑賞点</div>';
                trColHead.appendChild(tdRedWorkApp);

                // Center Judge
                trColHead.appendChild(createCell('審査員', 'col-header', 1, 1));

                // White Side Cols
                const tdWhiteWorkApp = createCell('作品点<br>鑑賞点', 'col-header', 1, 1);
                tdWhiteWorkApp.innerHTML = '作品点<div class="sub-label">鑑賞点</div>';
                trColHead.appendChild(tdWhiteWorkApp);
                trColHead.appendChild(createCell('合計', 'col-header', 1, 1));
                trColHead.appendChild(createCell('旗', 'col-header', 1, 1));

                tbody.appendChild(trColHead);


                // --- Data Rows (Judges) ---
                expectedIds.forEach(id => {
                    const s = subMap[id] || {};
                    const tr = document.createElement('tr');

                    // --- Red Side ---
                    // Flag
                    const tdRedFlag = createCell('', 'cell-flag red-flag');
                    if (s.red_flag) tdRedFlag.textContent = '◆';
                    tr.appendChild(tdRedFlag);

                    // Total
                    tr.appendChild(createCell(s.red_total != null ? s.red_total : '', 'cell-total'));

                    // Work / App (Stacked)
                    const tdRedScores = createCell('', 'cell-scores');
                    const redWorkDiv = document.createElement('div');
                    redWorkDiv.className = 'score-main';
                    redWorkDiv.textContent = s.red_work != null ? s.red_work : '';
                    const redAppDiv = document.createElement('div');
                    redAppDiv.className = 'score-sub';
                    redAppDiv.textContent = (s.red_app != null && s.red_app !== 0) ? s.red_app : '';
                    tdRedScores.appendChild(redWorkDiv);
                    tdRedScores.appendChild(redAppDiv);
                    tr.appendChild(tdRedScores);

                    // --- Judge Name (Center) ---
                    let name = id.slice(0, 8);
                    const j = judgesMap[id];
                    if (j) name = (typeof j === 'object' ? j.name : j) || name;
                    tr.appendChild(createCell(name, 'cell-judge'));

                    // --- White Side ---
                    // Work / App (Stacked)
                    const tdWhiteScores = createCell('', 'cell-scores');
                    const whiteWorkDiv = document.createElement('div');
                    whiteWorkDiv.className = 'score-main';
                    whiteWorkDiv.textContent = s.white_work != null ? s.white_work : '';
                    const whiteAppDiv = document.createElement('div');
                    whiteAppDiv.className = 'score-sub';
                    whiteAppDiv.textContent = (s.white_app != null && s.white_app !== 0) ? s.white_app : '';
                    tdWhiteScores.appendChild(whiteWorkDiv);
                    tdWhiteScores.appendChild(whiteAppDiv);
                    tr.appendChild(tdWhiteScores);

                    // Total
                    tr.appendChild(createCell(s.white_total != null ? s.white_total : '', 'cell-total'));

                    // Flag
                    const tdWhiteFlag = createCell('', 'cell-flag');
                    if (s.white_flag) {
                        tdWhiteFlag.textContent = '◆';
                        tdWhiteFlag.classList.add('white-flag');
                    }
                    tr.appendChild(tdWhiteFlag);
                    tbody.appendChild(tr);
                });

                scoreboardContainer.appendChild(table);
            }

            // Implementation of getBoutLabel:
            function getBoutLabel(epoch, total) {
                const map = ["先鋒戦", "次鋒戦", "中堅戦", "副将戦", "大将戦"];
                if (total === 5 && epoch >= 1 && epoch <= 5) return map[epoch - 1];
                if (total === 3 && epoch >= 1 && epoch <= 3) return ["先鋒戦", "中堅戦", "大将戦"][epoch - 1];
                return `第${epoch}戦`;
            }

            // Helper function to fetch JSON from Supabase
            async function fetchJson(tableName, params) {
                let url = `${SUPABASE_URL}/rest/v1/${tableName}`;
                const queryParams = [];
                if (params) {
                    for (const key in params) {
                        if (Object.prototype.hasOwnProperty.call(params, key)) {
                            queryParams.push(`${key}=${params[key]}`);
                        }
                    }
                }
                if (queryParams.length > 0) {
                    url += `?${queryParams.join('&')}`;
                }

                const res = await fetch(url, { headers });
                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`Failed to fetch ${tableName}: ${res.status} ${res.statusText} - ${errorText}`);
                }
                return res.json();
            }

            async function updateScoreboard() {
                try {
                    // console.log('Checking state...');
                    // 1. state
                    const stateRows = await fetchJson('state', {
                        select: 'epoch, current_match_id, accepting, scoreboard_visible',
                        id: 'eq.1'
                    });
                    const st = stateRows[0];
                    if (!st || !st.current_match_id) {
                        setStatus('No active match set in state.');
                        // if (mainCard) mainCard.style.opacity = '0'; // Debug: Comment out to keep visible if stuck
                        return;
                    }

                    // 同期表示フラグチェック
                    const isVisible = !!st.scoreboard_visible;
                    if (mainCard) {
                        mainCard.style.opacity = isVisible ? '1' : '0';
                    }

                    const matchId = st.current_match_id;
                    const epoch = st.epoch;
                    currentMatchId = matchId;
                    currentEpoch = epoch;

                    setStatus(`Active: match=${matchId}, epoch=${epoch}`);

                    // 2. matches
                    const matches = await fetchJson('matches', {
                        select: 'code,name,red_team_name,white_team_name,num_bouts',
                        id: 'eq.' + matchId
                    });
                    const match = matches[0];
                    if (!match) return;

                    // 3. expected_judges
                    const expected = await fetchJson('expected_judges', {
                        select: 'judge_id, sort_order',
                        match_id: 'eq.' + matchId,
                        order: 'sort_order.asc',
                    });
                    const expectedIds = expected.map(r => String(r.judge_id));

                    // 4. submissions
                    const subs = await fetchJson('submissions', {
                        select: '*',
                        match_id: 'eq.' + matchId,
                        epoch: 'eq.' + epoch,
                    });

                    // 5. judges details
                    let judgesMap = {};
                    if (expectedIds.length) {
                        const idList = expectedIds.join(',');
                        const judgeList = await fetchJson('judges', {
                            select: 'id,name',
                            id: 'in.(' + idList + ')',
                        });
                        judgesMap = Object.fromEntries(judgeList.map(j => [String(j.id), j.name]));
                    }

                    // データ整形
                    const subMap = {};
                    subs.forEach(s => { subMap[String(s.judge_id)] = s; });

                    // match.name に全角スペースがあれば改行に置換
                    const matchLabel = (match.name || match.code || '').replace(/　/g, '\n');

                    // boutLabelFull を生成 (scoreboard.js の getBoutLabel を利用)
                    let boutLabelFull = '';
                    if (typeof getBoutLabel === 'function') {
                        boutLabelFull = getBoutLabel(epoch, match.num_bouts);
                    } else {
                        // fallback
                        boutLabelFull = `第${epoch}戦`;
                    }

                    let boutLabelForBoard = boutLabelFull;
                    if (boutLabelForBoard && !boutLabelForBoard.endsWith('戦') && !boutLabelForBoard.includes('対戦')) {
                        boutLabelForBoard += '戦';
                    }

                    buildScoreboard(
                        expectedIds,
                        judgesMap,
                        subMap,
                        {
                            matchLabel,
                            boutLabelFull: boutLabelForBoard,
                            redTeamName: match.red_team_name || '紅',
                            whiteTeamName: match.white_team_name || '白',
                        },
                        scoreboardContainer
                    );

                } catch (err) {
                    console.error('Update Error:', err);
                    setStatus('Error: ' + err.message);
                }
            }

            window.addEventListener('beforeunload', () => {
                if (mainCard) {
                    mainCard.style.opacity = '0';
                }
            });

            // 初回実行
            updateScoreboard();
            // ポーリング
            setInterval(updateScoreboard, 1000);

        })();
    </script>
</body>

</html>